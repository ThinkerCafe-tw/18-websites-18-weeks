# 第八講:餐廳訂位網站 - 即時座位與訂位管理

## 單元目標

◆ 理解餐廳訂位系統與一般預約系統的差異  
◆ 掌握多座位管理與時段衝突防止機制  
◆ 學會設計翻桌率與尖峰時段控制邏輯  
◆ 建立即時座位狀態顯示與訂位確認流程

---

## 主文

### 8-1 餐廳訂位的複雜性:不只是「預約」這麼簡單

**一、為什麼餐廳訂位比診所預約更複雜?**

(一)回顧第 4 講:診所預約系統

還記得我們在第 4 講做過診所預約網站嗎?當時的邏輯很簡單:

```
診所預約的特性:
- 一位醫生,一個診間
- 每個時段只能一位病人
- 時段固定(例如:每半小時一位)
- 預約成功就鎖定該時段

衝突防止邏輯:
IF 時段 A 已被預約 → 就隱藏或顯示「已滿」
→ 簡單的「一對一」關係
```

**這個邏輯很直觀,對吧?**

---

(二)餐廳訂位的複雜度在哪裡?

但餐廳不一樣!讓我們看一個真實場景:

**場景:「義式小館」週五晚上 19:00**

```
餐廳資訊:
- 2 人桌 × 4 張
- 4 人桌 × 3 張
- 6 人桌 × 2 張
- 總共 9 張桌子,可容納約 32 人

當天訂位狀況:
19:00 已有 3 組訂位:
- A 先生,2 人,19:00
- B 小姐,4 人,19:00  
- C 先生,2 人,19:00
```

**問題來了:**

現在 D 先生打電話來:「我要訂 19:00,3 個人」

**你能接這筆訂位嗎?**

讓我們分析:
- 已訂 2+4+2 = 8 人
- 總容量 32 人
- 還有 24 個位置

**看起來可以接,對吧?**

**錯!**

**為什麼?**

因為:
- A 先生(2 人)占了一張 2 人桌
- B 小姐(4 人)占了一張 4 人桌
- C 先生(2 人)又占了一張 2 人桌

**剩餘桌子:**
- 2 人桌:還有 2 張
- 4 人桌:還有 2 張
- 6 人桌:還有 2 張

**D 先生要訂 3 人...**

→ 2 人桌太小,坐不下
→ 只能用 4 人桌或 6 人桌

**但這樣有效率嗎?**

用 4 人桌招待 3 人:
- 浪費 1 個位置
- 影響翻桌率
- 後面如果來 4 人組怎麼辦?

**這就是餐廳訂位的複雜性!**

---

**二、餐廳訂位系統的三大核心挑戰**

(一)挑戰 1:座位配置邏輯

**不是「有空位」就能訂!**

```
餐廳的座位配置考量:

1. 桌型匹配
   2 人來 → 優先安排 2 人桌
   4 人來 → 優先安排 4 人桌
   3 人來 → 需要決策(用 4 人桌?還是併桌?)

2. 效率最大化
   避免「大桌坐小組」導致浪費
   例如:6 人桌給 2 人坐 → 損失 4 個座位

3. 彈性調整
   尖峰時段可以「併桌」
   離峰時段可以「優待」
```

**實際案例:**

「米其林餐廳」的座位策略:
- 2 人組 → 一定給 2 人桌(除非已滿)
- 3 人組 → 19:00-20:00 用 4 人桌,其他時段可用 6 人桌
- 5 人組 → 併 4 人桌 + 2 人桌,或等 6 人桌

**這個邏輯你要寫進系統裡!**

---

(二)挑戰 2:時段與翻桌率管理

**餐廳不是「定點看診」,是「動態流動」!**

```
診所邏輯:
18:00-18:30 → 病人 A
18:30-19:00 → 病人 B  
19:00-19:30 → 病人 C
→ 固定切割,不重疊

餐廳邏輯:
19:00 進場 → 預估用餐 90 分鐘
20:30 離場 → 清理桌面 10 分鐘
20:40 可接下一組
→ 動態計算,需預估
```

**翻桌率的重要性:**

假設餐廳營業 18:00-22:00(4 小時):
- 如果每桌用餐 2 小時 → 每桌只能翻 2 次
- 如果每桌用餐 1.5 小時 → 每桌可以翻 2-3 次

**營收差異:**

```
餐廳:9 張桌,客單價 800 元

方案 A:不控制翻桌(平均 2 小時)
9 桌 × 2 次 × 800 = 14,400 元/晚

方案 B:控制翻桌(平均 1.5 小時)
9 桌 × 2.5 次 × 800 = 18,000 元/晚

差距:每晚 3,600 元
一個月差 10 萬元!
```

**所以餐廳會:**
- 設定「用餐時限」(例如:90 分鐘)
- 分配時段間隔(例如:30 分鐘一批)- 控制尖峰時段流量(避免全部擠在 19:00)

**你的訂位系統要能處理這些!**

---

(三)挑戰 3:即時狀態更新與衝突防止

**想像這個情況:**

```
18:55,A 先生在網站上看到「19:00 還有 4 人桌」
18:56,A 先生填寫訂位表單
18:57,B 小姐也在看網站,也看到「19:00 還有 4 人桌」
18:58,B 小姐也開始填表單
18:59,A 先生按下「確認訂位」→ 成功!
19:00,B 小姐也按下「確認訂位」→ ???
```

**問題:最後一張 4 人桌到底給誰?**

這就是「併發衝突」(Concurrency Conflict)

**解決方案:**
1. **即時庫存檢查**:確認訂位時再次檢查是否還有座位
2. **樂觀鎖定**:A 先確認就先給,B 後到就顯示「已滿」
3. **時間戳記驗證**:系統記錄每次座位狀態變更的時間

**這是第 4 講學過的,但餐廳更複雜!**

---

### 8-2 打造餐廳訂位系統:從座位表到訂位表單

**一、第一步:設計座位配置表(資料庫)**

(一)座位表的資料結構

**Supabase 資料表:tables**

```sql
欄位設計:
- table_id (主鍵):桌號,例如 T01、T02
- table_type:桌型,例如 2-seater、4-seater、6-seater  
- capacity:容納人數,例如 2、4、6
- location:位置,例如「窗邊」、「包廂」、「吧台」
- is_active:是否啟用,例如 true/false

範例資料:
table_id | table_type | capacity | location | is_active
---------|------------|----------|----------|----------
T01      | 2-seater   | 2        | 窗邊     | true
T02      | 2-seater   | 2        | 窗邊     | true  
T03      | 4-seater   | 4        | 中央     | true
T04      | 4-seater   | 4        | 包廂     | true
T05      | 6-seater   | 6        | 包廂     | true
```

**為什麼要這樣設計?**

- `table_type`:方便篩選「給 3 人找 4 人桌」
- `capacity`:做數學計算「還剩多少座位」
- `location`:提供選擇「我想坐窗邊」
- `is_active`:臨時停用某桌(例如維修)

---

(二)訂位記錄表的資料結構

**Supabase 資料表:reservations**

```sql
欄位設計:
- reservation_id (主鍵):訂位編號,自動生成
- customer_name:訂位人姓名
- phone:聯絡電話  
- email:Email(選填)
- party_size:人數
- reservation_date:訂位日期,例如 2025-12-25
- reservation_time:訂位時間,例如 19:00
- table_id:分配的桌號,例如 T03
- status:訂位狀態,例如「已確認」、「已取消」、「已完成」
- special_request:特殊需求,例如「生日蛋糕」、「嬰兒椅」
- created_at:建立時間,自動記錄

範例資料:
reservation_id | customer_name | phone       | party_size | reservation_date | reservation_time | table_id | status
---------------|---------------|-------------|------------|------------------|------------------|----------|--------
R20251201001   | 王大明        | 0912345678  | 4          | 2025-12-01       | 19:00            | T03      | 已確認
R20251201002   | 李小美        | 0923456789  | 2          | 2025-12-01       | 19:30            | T01      | 已確認
```

**重要邏輯:**

當 A 先生訂位後:
```sql
INSERT INTO reservations (
  customer_name, phone, party_size, 
  reservation_date, reservation_time, table_id, status
) VALUES (
  '王大明', '0912345678', 4,
  '2025-12-01', '19:00', 'T03', '已確認'
);
```

之後系統要檢查:
```sql
-- 查詢 19:00 已被訂位的桌子
SELECT table_id FROM reservations  
WHERE reservation_date = '2025-12-01'
AND reservation_time = '19:00'
AND status = '已確認';

-- 結果:T03 已被訂,不能再分配給別人
```

---

**二、第二步:建立訂位表單與座位選擇邏輯**

(一)用戶填寫訂位資訊

**前端設計:訂位表單**

```jsx
訂位表單欄位:
1. 選擇日期(DatePicker)
2. 選擇時段(Dropdown: 18:00/18:30/19:00/19:30...)
3. 選擇人數(Dropdown: 1-10 人)
4. 顯示「可用座位」狀態
5. 填寫姓名、電話
6. 特殊需求(TextArea)
7. 確認訂位按鈕
```

**關鍵:即時顯示「還有位子嗎?」**

當用戶選擇:
- 日期:2025-12-01
- 時段:19:00  
- 人數:4 人

系統要即時查詢並顯示:
```
✓ 還有 2 張 4 人桌可選
✓ 也可選 1 張 6 人桌(較寬敞)
```

---

(二)座位匹配演算法

**AI 對話範例:**

```
你:「我要設計一個餐廳訂位系統。當客人選擇 4 人、19:00 時段時,
系統要自動推薦合適的桌子。餐廳有 2 人桌 4 張、4 人桌 3 張、6 人桌 2 張。
請幫我寫一個函數,輸入人數,輸出推薦的桌型。」

Claude:「好的!我來設計這個座位匹配邏輯...

function findSuitableTables(partySize, availableTables) {
  // 優先匹配剛好的桌型
  const exactMatch = availableTables.filter(
    table => table.capacity === partySize && table.is_available
  );
  
  if (exactMatch.length > 0) {
    return {
      recommended: exactMatch,
      message: `有 ${exactMatch.length} 張 ${partySize} 人桌可選`
    };
  }
  
  // 找稍大一號的桌子
  const largerTables = availableTables.filter(
    table => table.capacity > partySize && 
             table.capacity <= partySize + 2 &&
             table.is_available
  ).sort((a, b) => a.capacity - b.capacity);
  
  if (largerTables.length > 0) {
    return {
      recommended: largerTables,
      message: `${partySize} 人桌已滿,推薦 ${largerTables[0].capacity} 人桌`
    };
  }
  
  // 都沒有
  return {
    recommended: [],
    message: '很抱歉,此時段已無合適座位'
  };
}

這個函數會:
1. 優先找「剛好」的桌子(4 人找 4 人桌)
2. 找不到就找「稍大」的桌子(4 人用 6 人桌)
3. 都沒有就顯示「已滿」

要整合進 React 頁面嗎?」
```

**你:「要!而且我希望即時更新,當別人訂位後,我看到的座位數也要跟著變。」**

Claude 就會幫你寫出即時查詢的邏輯:
```javascript
// 即時查詢可用座位
useEffect(() => {
  const checkAvailability = async () => {
    // 查詢該時段已被訂的桌子
    const { data: bookedTables } = await supabase
      .from('reservations')
      .select('table_id')
      .eq('reservation_date', selectedDate)
      .eq('reservation_time', selectedTime)
      .eq('status', '已確認');
    
    // 查詢所有桌子
    const { data: allTables } = await supabase
      .from('tables')
      .select('*')
      .eq('is_active', true);
    
    // 過濾掉已被訂的
    const availableTables = allTables.filter(
      table => !bookedTables.some(b => b.table_id === table.table_id)
    );
    
    // 用剛才的函數找合適的桌子
    const result = findSuitableTables(partySize, availableTables);
    setAvailableTables(result);
  };
  
  checkAvailability();
}, [selectedDate, selectedTime, partySize]);
```

**這就是 AI 協作的威力!**

---

**三、第三步:確認訂位與衝突防止**

(一)樂觀鎖定機制

**什麼是樂觀鎖定?**

```
情境:A 和 B 同時想訂 19:00 的最後一張 4 人桌

傳統做法(悲觀鎖定):
- A 點進表單 → 系統鎖定這張桌子 30 秒
- B 點進表單 → 看到「已被鎖定」
→ 問題:如果 A 不訂怎麼辦?白白浪費 30 秒

現代做法(樂觀鎖定):
- A 和 B 都能看到「還有位子」
- A 先按下「確認」→ 檢查 → 成功訂位
- B 後按下「確認」→ 檢查 → 顯示「已滿,請選其他時段」
→ 誰先確認誰先贏
```

**如何實作?**

```javascript
async function confirmReservation(formData) {
  // 步驟 1:最後檢查一次
  const { data: existingBooking } = await supabase
    .from('reservations')
    .select('*')
    .eq('table_id', formData.table_id)
    .eq('reservation_date', formData.date)
    .eq('reservation_time', formData.time)
    .eq('status', '已確認');
  
  // 步驟 2:如果已經有人訂了
  if (existingBooking.length > 0) {
    return {
      success: false,
      message: '很抱歉,此座位剛剛已被預訂,請選擇其他時段'
    };
  }
  
  // 步驟 3:確認可以訂,寫入資料庫
  const { data, error } = await supabase
    .from('reservations')
    .insert([{
      customer_name: formData.name,
      phone: formData.phone,
      party_size: formData.party_size,
      reservation_date: formData.date,
      reservation_time: formData.time,
      table_id: formData.table_id,
      status: '已確認'
    }]);
  
  if (error) {
    return {
      success: false, 
      message: '訂位失敗,請稍後再試'
    };
  }
  
  return {
    success: true,
    message: '訂位成功!我們將發送確認簡訊到您的手機'
  };
}
```

**這個邏輯保證:**
- 不會重複訂位
- 即時反應座位狀態
- 友善的錯誤提示

---

### 8-3 進階功能:讓訂位系統更聰明

**一、自動分配座位(智慧推薦)**

(一)為什麼需要自動分配?

**傳統流程:**
```
客人訂位 → 餐廳人員接電話 → 翻本子看哪桌有空 → 手動分配
→ 麻煩!容易出錯!
```

**有了系統:**
```
客人線上訂位 → 系統自動推薦最佳桌子 → 確認 → 完成
→ 省時!減少人為錯誤!
```

**自動分配的邏輯:**

```javascript
function autoAssignTable(partySize, reservationTime, availableTables) {
  // 策略 1:尖峰時段(18:00-20:00)嚴格匹配
  if (reservationTime >= '18:00' && reservationTime <= '20:00') {
    // 4 人就一定要 4 人桌,避免浪費
    return availableTables.find(t => t.capacity === partySize);
  }
  
  // 策略 2:離峰時段彈性安排
  else {
    // 可以給大一點的桌子,提升客人體驗
    return availableTables.find(t => t.capacity >= partySize);
  }
}
```

這個邏輯讓餐廳:
- 尖峰時段「效率優先」
- 離峰時段「體驗優先」

---

**二、翻桌率控制與時段間隔設計**

(一)為什麼要控制時段間隔?

**沒有控制的情況:**
```
19:00 → 9 組客人同時進場
→ 廚房爆單!
→ 上菜慢!
→ 客人抱怨!
→ 負評!
```

**有控制的情況:**
```
18:00 → 2 組
18:30 → 2 組  
19:00 → 3 組
19:30 → 2 組
→ 廚房平穩出餐
→ 服務品質佳
→ 好評!
```

**如何實作?**

```javascript
// 設定每個時段的「最大接待組數」
const timeSlotLimits = {
  '18:00': 2,
  '18:30': 2,
  '19:00': 3,
  '19:30': 2,
  '20:00': 2,
  '20:30': 1
};

// 檢查時段是否還能接受訂位
async function checkTimeSlotAvailability(date, time) {
  const { data: bookings } = await supabase
    .from('reservations')
    .select('*')
    .eq('reservation_date', date)
    .eq('reservation_time', time)
    .eq('status', '已確認');
  
  const currentCount = bookings.length;
  const maxCount = timeSlotLimits[time] || 3;
  
  return {
    available: currentCount < maxCount,
    remaining: maxCount - currentCount
  };
}
```

前端顯示:
```
18:00 ✓ 還可接受 2 組
18:30 ✓ 還可接受 1 組
19:00 ✗ 已額滿
19:30 ✓ 還可接受 2 組
```

---

**三、訂位提醒與確認機制**

(一)Email 確認信

**訂位成功後立即發送:**

```
主旨:【義式小館】訂位確認 - 王大明先生

親愛的王大明先生您好,

感謝您的訂位!

訂位資訊:
- 日期:2025 年 12 月 1 日(週日)
- 時間:晚上 7:00
- 人數:4 位
- 桌號:T03(4 人桌,中央區)
- 訂位編號:R20251201001

特別提醒:
• 請提前 10 分鐘到達
• 若遲到超過 15 分鐘,座位將釋出給現場候位客人
• 如需取消或更改,請來電 02-2345-6789

期待您的光臨!

義式小館 敬上
```

(二)前一天 SMS 提醒

**自動發送簡訊:**

```
【義式小館】提醒您明天(12/1)19:00 的訂位。
4 位/T03 桌。期待您的光臨!如需取消請回 C。
```

(三)No-show 處理機制

**客人沒來怎麼辦?**

```javascript
// 定時檢查 No-show
async function checkNoShows() {
  const now = new Date();
  const fifteenMinutesAgo = new Date(now - 15 * 60 * 1000);
  
  // 找出 15 分鐘前的訂位,但客人還沒來的
  const { data: noShows } = await supabase
    .from('reservations')
    .select('*')
    .eq('status', '已確認')
    .lte('reservation_time', fifteenMinutesAgo)
    .is('checked_in_at', null);
  
  // 將這些訂位標記為 No-show,釋放座位
  for (const booking of noShows) {
    await supabase
      .from('reservations')
      .update({ status: 'No-show' })
      .eq('reservation_id', booking.reservation_id);
  }
}
```

這樣可以:
- 避免座位浪費
- 釋放給現場候位的客人

---

### 8-4 從訂位系統到餐廳管理平台

**一、店家後台:今天的訂位一覽表**

(一)餐廳需要什麼資訊?

**後台儀表板應該顯示:**

```
今日訂位總覽 (2025-12-01)
━━━━━━━━━━━━━━━━━━━
18:00
  ✓ T01 | 王大明 | 2 人 | 0912-345-678
  ✓ T03 | 李小美 | 4 人 | 0923-456-789
  
18:30  
  ✓ T02 | 張先生 | 2 人 | 0934-567-890
  ⏰ T04 | 林小姐 | 4 人 | 0945-678-901 (未確認)
  
19:00
  ✓ T05 | 陳先生 | 6 人 | 0956-789-012
  ✓ T06 | 黃小姐 | 2 人 | 0967-890-123
  ✗ T03 | 劉先生 | 4 人 | 0978-901-234 (已取消)

━━━━━━━━━━━━━━━━━━━
統計:
- 總訂位數:7 組
- 已確認:5 組(20 人)
- 未確認:1 組(4 人)
- 已取消:1 組
- 翻桌率:預估 2.1 次
```

(二)快速操作功能

**後台需要的功能:**

1. **一鍵確認訂位**:客人來電確認時快速標記
2. **Check-in 打勾**:客人到店時標記「已到店」
3. **快速取消**:客人臨時取消時標記
4. **手動新增訂位**:電話訂位時快速輸入
5. **座位狀態調整**:某桌臨時故障時標記「停用」

**這些都是一行程式碼的事!**

```javascript
// 確認訂位
await supabase
  .from('reservations')
  .update({ status: '已確認' })
  .eq('reservation_id', reservationId);

// Check-in
await supabase
  .from('reservations')
  .update({ 
    status: '已到店',
    checked_in_at: new Date()
  })
  .eq('reservation_id', reservationId);
```

---

**二、數據分析:訂位趨勢與優化建議**

(一)哪個時段最熱門?

```sql
SELECT reservation_time, COUNT(*) as booking_count
FROM reservations
WHERE reservation_date BETWEEN '2025-11-01' AND '2025-11-30'
AND status = '已確認'
GROUP BY reservation_time
ORDER BY booking_count DESC;

結果:
19:00 → 45 組(最熱門!)
19:30 → 38 組
18:30 → 25 組
18:00 → 18 組
20:00 → 12 組
```

**策略調整:**
- 19:00 是黃金時段 → 可以提高最低消費
- 18:00 較冷清 → 推出早鳥優惠吸引客人

(二)No-show 率分析

```sql
SELECT 
  COUNT(*) as total_bookings,
  SUM(CASE WHEN status = 'No-show' THEN 1 ELSE 0 END) as no_shows,
  ROUND(100.0 * SUM(CASE WHEN status = 'No-show' THEN 1 ELSE 0 END) / COUNT(*), 2) as no_show_rate
FROM reservations
WHERE reservation_date BETWEEN '2025-11-01' AND '2025-11-30';

結果:
總訂位數:180 組
No-show:12 組  
No-show 率:6.67%
```

**如果 No-show 率太高:**
- 要求信用卡擔保
- 收取訂位保證金
- 前一天再次確認

---

**三、與第 4 講的比較:你學到了什麼?**

(一)複雜度提升

```
第 4 講:診所預約
- 1 個醫生,1 個診間
- 時段固定,簡單衝突檢查
- 邏輯:一對一

第 8 講:餐廳訂位  
- 9 張桌子,3 種桌型
- 時段彈性,複雜配對邏輯
- 翻桌率考量
- 邏輯:多對多 + 動態調整
```

(二)你現在會什麼了?

✓ 多資源管理(多張桌子)
✓ 動態配對邏輯(人數 vs 桌型)
✓ 併發衝突處理(樂觀鎖定)
✓ 業務邏輯優化(翻桌率、時段控制)
✓ 數據分析與決策支援

**你的技能等級:從「初階」晉升到「中階」!**

---

### 8-5 實戰建議:如何接案與報價

**一、餐廳訂位系統的接案行情**

(一)功能等級與報價

**基礎版(2-3 萬):**
- 線上訂位表單
- 座位配置與即時顯示
- Email 確認信
- 簡易後台(今日訂位一覽)

**標準版(3-5 萬):**
- 基礎版所有功能
- SMS 提醒
- 自動座位分配
- 翻桌率控制
- No-show 處理機制
- 數據分析報表

**進階版(5-8 萬):**
- 標準版所有功能
- 會員系統整合(記住常客偏好)
- 候位管理系統
- 線上候位取號
- 多分店管理
- POS 系統整合

---

(二)客戶會問什麼問題?

**問題 1:「能不能串接 LINE 通知?」**

你:「可以!訂位成功後,系統會透過 LINE Notify 發送確認訊息給店家。
這樣店長隨時都能在 LINE 上看到新訂位。這是標準版的功能。」

**問題 2:「可以防止惡意訂位嗎?」**

你:「有三種做法:
1. 基礎版:手機號碼驗證 + Email 確認
2. 標準版:前一天 SMS 再次確認,未回覆則自動取消
3. 進階版:信用卡預刷保證金,No-show 則扣款

建議從第 2 種開始,對客人友善但也能防止惡意。」

**問題 3:「我們有包廂,可以讓客人指定嗎?」**

你:「當然!座位表裡可以設定『location』欄位,例如『包廂』、『窗邊』、『吧台』。
客人訂位時可以勾選偏好,系統會優先分配。這是標準版功能。」

---

**二、開發時程規劃**

(一)AI 協作開發的實際時程

```
Day 1:資料庫設計與表單建立(4 小時)
- 設計 tables 和 reservations 資料表
- 建立前端訂位表單
- 串接 Supabase

Day 2:核心邏輯開發(6 小時)
- 座位匹配演算法
- 即時座位狀態查詢
- 訂位確認與衝突檢查

Day 3:後台與通知功能(4 小時)
- 餐廳後台儀表板
- Email 確認信
- SMS 提醒設定

Day 4:測試與優化(3 小時)
- 測試各種情境
- 處理 edge cases
- 效能優化

Day 5:部署與交付(2 小時)
- Vercel 部署
- 教育客戶使用後台
- 交付文件與操作手冊

總時程:約 3-4 個工作天(19 小時)
```

**搭配 AI:速度快 3-5 倍!**

---

**三、提案時的加分技巧**

(一)展示類似案例

**提案時說:**

「我最近幫『米其林小館』做了一套訂位系統,他們原本每天花 2 小時接電話訂位,
現在 80% 的訂位都在線上完成,只剩 20% 需要電話處理。

而且系統會自動提醒客人,No-show 率從 15% 降到 5%,
相當於每個月多賺回 10 桌的營業額!」

**具體數字 + 實際效益 = 說服力!**

---

(二)提供「試用期」方案

**建議說法:**

「我們可以先做基礎版,您試用一個月。如果效果好,再升級到標準版,
把 SMS 提醒和數據分析加進去。這樣您可以先確認系統符合需求,
我們也能根據您的實際使用情況調整功能。」

**降低客戶決策風險 = 提高成交率!**

---

(三)提供「月租」而非「買斷」

**定價策略:**

```
方案 A:買斷制(3 萬)
- 一次付清
- 含 3 個月維護
- 之後維護另計

方案 B:月租制(5,000 元/月)
- 包含維護與更新
- 包含主機與資料庫費用  
- 隨時可升級功能
- 最低租用 6 個月

推薦 B 方案的理由:
1. 客戶初期負擔低
2. 你有穩定收入
3. 客戶需求會變,容易追加銷售
```

**月租制 = 長期合作 = 穩定收入!**

---

## 重要名詞

◆ **翻桌率(Table Turnover Rate)**：餐廳在一個營業時段內,每張桌子被使用的次數。例如:一張桌子在 4 小時內接待 2 組客人,翻桌率就是 2 次。翻桌率越高,餐廳營收越好。

◆ **樂觀鎖定(Optimistic Locking)**：一種併發控制策略。系統假設衝突很少發生,讓多個用戶同時操作,只在最後確認時檢查衝突。適合高併發、低衝突的場景(如訂位系統)。

◆ **悲觀鎖定(Pessimistic Locking)**：另一種併發控制策略。系統假設衝突很常發生,當一個用戶開始操作時就鎖定資源,其他用戶必須等待。適合高衝突的場景。

◆ **No-show**：訂位後未到店的情況。餐廳的 No-show 率通常在 5-15% 之間,造成座位浪費與營收損失。透過提醒機制與保證金制度可以降低 No-show 率。

◆ **時段間隔(Time Slot Interval)**：訂位系統中,每個可預訂時段之間的間隔時間。例如:18:00、18:30、19:00...間隔是 30 分鐘。合理的時段間隔可以分散客流,避免廚房爆單。

◆ **座位配置演算法(Table Assignment Algorithm)**：根據客人人數自動推薦或分配最合適座位的邏輯。通常遵循「剛好匹配優先,避免浪費」的原則,例如:4 人優先安排 4 人桌,而非 6 人桌。

◆ **併發衝突(Concurrency Conflict)**：多個用戶同時操作同一筆資料時,可能產生的不一致狀態。例如:A 和 B 同時訂同一張桌子,系統必須確保只有一人能成功訂位。

◆ **即時庫存(Real-time Inventory)**：系統中資源(如座位)的即時可用狀態。每次訂位成功或取消時,庫存狀態必須立即更新,確保其他用戶看到的是最新狀況。

---

## 自我評量或問題與討論

1. **比較題**:請比較「診所預約系統」(第 4 講)與「餐廳訂位系統」(第 8 講)的差異。從資源管理、時段邏輯、衝突處理三個面向分析,哪一個系統更複雜?為什麼?

2. **情境題**:假設你是「義式小館」的老闆,餐廳有 2 人桌 4 張、4 人桌 3 張、6 人桌 2 張。某個週五晚上 19:00 已有 3 組訂位:2 人×2 組、4 人×1 組。現在又有一組 3 人想訂 19:00,你會接嗎?如果接,要安排哪種桌型?為什麼?

3. **設計題**:請設計一個「翻桌率優化策略」。假設餐廳營業時間 18:00-22:00(4 小時),平均用餐時間 90 分鐘。你會如何設計時段間隔?如何在系統中實作「用餐時限提醒」功能?

4. **實作題**:請用 AI(Claude)生成一個函數:`checkTimeSlotAvailability(date, time, partySize)`,功能是檢查指定日期、時段、人數的訂位是否還有空位。函數應回傳:`{ available: true/false, message: '說明文字' }`。

5. **商業思考題**:餐廳的 No-show 率約 10%,每月損失約 5 萬元營收。客戶問你:「系統能不能幫我降低 No-show?」你會提出哪些解決方案?哪個方案最可行?為什麼?

---

## 參考文獻/書目

1. Supabase 官方文檔 - 資料庫設計與即時查詢  
   https://supabase.com/docs

2. React Hook Form - 表單驗證與狀態管理  
   https://react-hook-form.com

3. 《餐飲業數位轉型實戰手冊》,數位時代雜誌,2024

4. 《訂位系統設計模式》,Restaurant Technology News,2024

5. Vercel 部署指南 - Next.js 應用上線實務  
   https://vercel.com/docs

6. 《併發控制與資料一致性》,Database Design Patterns,O'Reilly Media,2023

7. Twilio Programmable SMS API - 簡訊發送整合文件  
   https://www.twilio.com/docs/sms

8. 《翻桌率優化:餐廳營收管理策略》,Restaurant Management Magazine,2024